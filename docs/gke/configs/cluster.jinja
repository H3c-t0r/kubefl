{#
Copyright 2016 Google Inc. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
#}


{% set NAME_PREFIX = env['deployment'] + '-' + env['name'] %}
{% set CLUSTER_NAME = NAME_PREFIX %}
{% set CPU_POOL = NAME_PREFIX + '-cpu-pool-' + properties['pool-version'] %}
{% set GPU_POOL = NAME_PREFIX + '-gpu-pool-' + properties['pool-version'] %}
{% set TYPE_NAME = NAME_PREFIX + '-type' %}
{% set RBAC_TYPE_NAME = TYPE_NAME + '-rbac-v1' %}

{% set K8S_ENDPOINTS = {'': 'api/v1', '-v1beta1-extensions': 'apis/extensions/v1beta1', '-rbac-v1': 'apis/rbac.authorization.k8s.io/v1'}  %}

{% set CLUSTER_TYPE_API_V1 = env['project'] + '/' + TYPE_NAME %}
{% set RBAC_TYPE = env['project'] + '/' + RBAC_TYPE_NAME %}

{% set COLLECTION_PREFIX = '/api/v1/namespaces/{namespace}/' %}
{% set NAMESPACE_COLLECTION = '/api/v1/namespaces' %}
{% set RC_COLLECTION = COLLECTION_PREFIX + 'replicationcontrollers' %}
{% set SERVICE_COLLECTION = COLLECTION_PREFIX + 'services' %}
{% set CLUSTER_ROLE_BINDING_COLLECTION = '/apis/rbac.authorization.k8s.io/v1/clusterrolebindings' %}

resources:
- name: {{ CLUSTER_NAME }}
  type: container.v1.cluster
  properties:
    zone: {{ properties['zone'] }}
    cluster:
      name: {{ CLUSTER_NAME }}
      # Create a very small minimal pool. Actual nodes will be managed
      # as additional node pools. This makes it easier to 
      initialNodeCount: 1
      machineType: n1-standard-1
      {% if properties['stackdriver-kubernetes'] %}
      # TODO: remove alpha when 10.2 is public.
      # https://github.com/kubeflow/kubeflow/issues/821
      enableKubernetesAlpha: true
      # We need 1.10.2 to support Stackdrivier GKE.
      initialClusterVersion: 1.10.2-gke.0
      # Logging and monitoring have default value [logging/monitoring].googleapis.com
      # if not set. We are using the new Stackdricer Kubernetes agents here.
      # See cloud.google.com/monitoring/kubernetes-engine/.
      loggingService: logging.googleapis.com/kubernetes
      monitoringService: monitoring.googleapis.com/kubernetes
      {% else %}
      initialClusterVersion: 1.9.6-gke.1
      {% endif %}      
      nodeConfig:
        oauthScopes:        
        - https://www.googleapis.com/auth/compute
        - https://www.googleapis.com/auth/devstorage.read_only
        - https://www.googleapis.com/auth/logging.write
        - https://www.googleapis.com/auth/monitoring

# We manage the node pools as separate resources.
# We do this so that if we want to make changes we can delete the existing resource and then recreate it.
# Updating doesn't work so well because we are limited in what changes GKE's update method supports.

- name: {{ CPU_POOL }}
  type: container.v1.nodePool
  properties:
    project: {{ properties['project'] }}
    zone: {{ properties['zone'] }}
    clusterId: {{ CLUSTER_NAME }}
    nodePool:
      name: cpu-pool      
      initialNodeCount: {{ properties['cpu-pool-initialNodeCount'] }}
      config:          
        machineType: n1-standard-8
        oauthScopes:
          - https://www.googleapis.com/auth/compute
          - https://www.googleapis.com/auth/devstorage.read_only
          - https://www.googleapis.com/auth/logging.write
          - https://www.googleapis.com/auth/monitoring

  metadata:
    dependsOn:
    - {{ CLUSTER_NAME }}

- name: {{ GPU_POOL }}
  type: container.v1.nodePool
  properties:
    project: {{ properties['project'] }}
    zone: {{ properties['zone'] }}
    clusterId: {{ CLUSTER_NAME }}
    nodePool:
      name: gpu-pool      
      initialNodeCount: {{ properties['gpu-pool-initialNodeCount'] }}
      config:          
        machineType: n1-standard-8
        oauthScopes:
        # Attaching cloud-platform scope to nodes is not good practice
        # But it simplifies demos.
          - https://www.googleapis.com/auth/cloud-platform
          - https://www.googleapis.com/auth/compute
          - https://www.googleapis.com/auth/devstorage.read_only
          - https://www.googleapis.com/auth/logging.write
          - https://www.googleapis.com/auth/monitoring
        accelerators:
          - acceleratorCount: 1
            acceleratorType: nvidia-tesla-k80

  metadata:
    dependsOn:
    # We can only create 1 node pool at a time.
    - {{ CPU_POOL }}

- name: static-ip
  type: compute.v1.globalAddress
  properties:
    project: {{ properties['project'] }}
    name: {{ CLUSTER_NAME }}
    description: "Static IP for ingress."


{#

Define TypeProviders for different K8s endpoints. 
https://cloud.google.com/deployment-manager/docs/configuration/type-providers/process-adding-api
This allows K8s resources to be created using Deployment manager.
We use this to create the minimal resources needed to startup and deploy Kubeflow via the bootstrapper;
e.g. creating namespaces, service accounts, stateful set to run the bootstrapper.

#}
{% for typeSuffix, endpoint in K8S_ENDPOINTS.iteritems() %}
- name: {{ TYPE_NAME }}{{ typeSuffix }}
  type: deploymentmanager.v2beta.typeProvider
  properties:
    options:
      validationOptions:
        # Kubernetes API accepts ints, in fields they annotate with string.
        # This validation will show as warning rather than failure for
        # Deployment Manager.
        # https://github.com/kubernetes/kubernetes/issues/2971
        schemaValidation: IGNORE_WITH_WARNINGS
      # According to kubernetes spec, the path parameter 'name'
      # should be the value inside the metadata field
      # https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md
      # This mapping specifies that
      inputMappings:
      - fieldName: name
        location: PATH
        methodMatch: ^(GET|DELETE|PUT)$
        value: $.ifNull($.resource.properties.metadata.name, $.resource.name)
      - fieldName: metadata.name
        location: BODY
        methodMatch: ^(PUT|POST)$
        value: $.ifNull($.resource.properties.metadata.name, $.resource.name)
      - fieldName: Authorization
        location: HEADER
        value: >
          $.concat("Bearer ", $.googleOauth2AccessToken())
    descriptorUrl: https://$(ref.{{ CLUSTER_NAME }}.endpoint)/swaggerapi/{{ endpoint }}
{% endfor %}

{# Enable the resource manager API. This is needed below to get IAM policy.
 If activating multiple APIs you might want to serialize them.
 #}
- name: resource-manager-api
  type: deploymentmanager.v2.virtual.enableService
  properties: 
    consumerId: {{ 'project:' + env['project'] }}
    serviceName: cloudresourcemanager.googleapis.com

{# Get the IAM policy first so that we do not remove any existing bindings. #}
- name: get-iam-policy
  action: gcp-types/cloudresourcemanager-v1:cloudresourcemanager.projects.getIamPolicy
  properties: 
    resource: {{ env['project'] }}
        
  metadata:
    dependsOn:
      - resource-manager-api
    runtimePolicy: 
      - UPDATE_ALWAYS 

{# Set the IAM policy patching the existing policy with what ever is currently in the
  config. 

  We need to make the cloudservices account a GKE cluster admin because deployment manager
  users the cloudservices account; so this will be the identity used with the K*s cluster.

  Note: This will fail if the cloudservices account doesn't have IamProjectAdmin
  permissions.
#}
- name: patch-iam-policy
  action: gcp-types/cloudresourcemanager-v1:cloudresourcemanager.projects.setIamPolicy
  properties: 
    resource: {{ env['project'] }}
    policy: $(ref.get-iam-policy)
    gcpIamPolicyPatch:
      add: 
        - role: roles/container.admin
          members:
            - {{ 'serviceAccount:' + env['project_number'] + '@cloudservices.gserviceaccount.com' }}
      remove: []

  metadata:
    dependsOn:
      - get-iam-policy
    runtimePolicy: 
      - UPDATE_ALWAYS 

{#  Namespace for bootstrapper. #}
- name: admin-namespace
  type: {{ CLUSTER_TYPE_API_V1 }}:{{ NAMESPACE_COLLECTION }}
  properties:
    apiVersion: v1
    kind: Namespace
    metadata:
      name: kubeflow-admin    
    spec:

  metadata:
      dependsOn:
      # Wait for the type provider to be created.
      - {{ TYPE_NAME }}

{#  StatefulSet needs a service. #}
- name: bootstrap-service
  type: {{ CLUSTER_TYPE_API_V1 }}:{{ SERVICE_COLLECTION }}
  properties:
    apiVersion: v1
    kind: Service
    namespace: kubeflow-admin
    metadata:
      name: kubeflow-bootstrapper
      namespace: kubeflow-admin
    spec:
      ClusterIp: "None"
      selector:

  metadata:
      dependsOn:
      # Wait for the type provider to be created.
      - admin-namespace

{# The deployment manager uses the cloudservices account. We need to create
   a cluster role binding making the cloudservices account cluster admin
   so that we can then create other cluster role bindings.
#}
- name: dm-rbac
  type: {{ RBAC_TYPE }}:{{ CLUSTER_ROLE_BINDING_COLLECTION }}
  properties:
    apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRoleBinding
    metadata:
      name: cloud-services-cluster-admin
    subjects:
      - kind: User
        name: {{ env['project_number'] + '@cloudservices.gserviceaccount.com' }}
    roleRef:
      kind: ClusterRole
      name: cluster-admin
      apiGroup: rbac.authorization.k8s.io
  metadata:
    dependsOn:
      - {{ RBAC_TYPE_NAME }}
      - admin-namespace

{# Make the default service account in the kubeflow-admin namespace a cluster admin.
   Cluster admin priveleges are needed by the bootstrapper.
#}
- name: bootstrap-rbac
  type: {{ RBAC_TYPE }}:{{ CLUSTER_ROLE_BINDING_COLLECTION }}
  properties:
    apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRoleBinding
    metadata:
      name: kubeflow-cluster-admin
    subjects:
      - kind: ServiceAccount
        name: default
        namespace: kubeflow-admin
    roleRef:
      kind: ClusterRole
      name: cluster-admin
      apiGroup: rbac.authorization.k8s.io
  metadata:
    dependsOn:
      - {{ RBAC_TYPE_NAME }}
      - admin-namespace
      - dm-rbac

outputs:
{% for typeSuffix, endpoint in K8S_ENDPOINTS.iteritems() %}
- name: clusterType{{ typeSuffix }}
  value: {{ TYPE_NAME }}{{ typeSuffix }}
{% endfor %}
