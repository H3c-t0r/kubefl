{"ast":null,"code":"/* eslint-disable no-bitwise */\nexport const JWT_SECRET = 'devias-top-secret-key';\nexport const JWT_EXPIRES_IN = 3600 * 24 * 2; // 2 days\n// Since we are unable to sign a JWT in a browser\n// because \"jsonwebtoken\" library is available on server side only, NodeJS environment\n// we simply simulate a signed token, no complex checks because on server side\n// you're using the library\n\nexport const sign = (payload, privateKey, header) => {\n  const now = new Date();\n  const newHeader = { ...header\n  };\n  newHeader.expiresIn = new Date(now.getTime() + newHeader.expiresIn);\n  const encodedHeader = btoa(JSON.stringify(newHeader));\n  const encodedPayload = btoa(JSON.stringify(payload));\n  const signature = btoa(Array.from(encodedPayload).map((item, key) => String.fromCharCode(item.charCodeAt(0) ^ privateKey[key % privateKey.length].charCodeAt(0))).join(''));\n  return `${encodedHeader}.${encodedPayload}.${signature}`;\n}; // Since we create a fake signed token, we have to implement a fake jwt decode\n// platform to simulate \"jwt-decode\" library.\n\nexport const decode = token => {\n  const [encodedHeader, encodedPayload, signature] = token.split('.');\n  const header = JSON.parse(atob(encodedHeader));\n  const payload = JSON.parse(atob(encodedPayload));\n  const now = new Date();\n\n  if (now < header.expiresIn) {\n    throw new Error('Expired token');\n  }\n\n  const verifiedSignature = btoa(Array.from(encodedPayload).map((item, key) => String.fromCharCode(item.charCodeAt(0) ^ JWT_SECRET[key % JWT_SECRET.length].charCodeAt(0))).join(''));\n\n  if (verifiedSignature !== signature) {\n    throw new Error('Invalid signature');\n  }\n\n  return payload;\n};\nexport const verify = (token, privateKey) => {\n  const [encodedHeader, encodedPayload, signature] = token.split('.');\n  const header = JSON.parse(atob(encodedHeader));\n  const payload = JSON.parse(atob(encodedPayload));\n  const now = new Date();\n\n  if (now < header.expiresIn) {\n    throw new Error('Expired token');\n  }\n\n  const verifiedSignature = btoa(Array.from(encodedPayload).map((item, key) => String.fromCharCode(item.charCodeAt(0) ^ privateKey[key % privateKey.length].charCodeAt(0))).join(''));\n\n  if (verifiedSignature !== signature) {\n    throw new Error('Invalid signature');\n  }\n\n  return payload;\n};","map":{"version":3,"sources":["/Users/allan.chepkoy/cloud/kubeflow/components/zoradashboard/src/utils/jwt.js"],"names":["JWT_SECRET","JWT_EXPIRES_IN","sign","payload","privateKey","header","now","Date","newHeader","expiresIn","getTime","encodedHeader","btoa","JSON","stringify","encodedPayload","signature","Array","from","map","item","key","String","fromCharCode","charCodeAt","length","join","decode","token","split","parse","atob","Error","verifiedSignature","verify"],"mappings":"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","sourcesContent":["/* eslint-disable no-bitwise */\nexport const JWT_SECRET = 'devias-top-secret-key';\nexport const JWT_EXPIRES_IN = 3600 * 24 * 2; // 2 days\n\n// Since we are unable to sign a JWT in a browser\n// because \"jsonwebtoken\" library is available on server side only, NodeJS environment\n// we simply simulate a signed token, no complex checks because on server side\n// you're using the library\nexport const sign = (payload, privateKey, header) => {\n  const now = new Date();\n  const newHeader = { ...header };\n  newHeader.expiresIn = new Date(now.getTime() + newHeader.expiresIn);\n  const encodedHeader = btoa(JSON.stringify(newHeader));\n  const encodedPayload = btoa(JSON.stringify(payload));\n  const signature = btoa(Array\n    .from(encodedPayload)\n    .map((item, key) => (String.fromCharCode(item.charCodeAt(0) ^ privateKey[key\n    % privateKey.length].charCodeAt(0))))\n    .join(''));\n\n  return `${encodedHeader}.${encodedPayload}.${signature}`;\n};\n\n// Since we create a fake signed token, we have to implement a fake jwt decode\n// platform to simulate \"jwt-decode\" library.\nexport const decode = (token) => {\n  const [encodedHeader, encodedPayload, signature] = token.split('.');\n  const header = JSON.parse(atob(encodedHeader));\n  const payload = JSON.parse(atob(encodedPayload));\n  const now = new Date();\n\n  if (now < header.expiresIn) {\n    throw new Error('Expired token');\n  }\n\n  const verifiedSignature = btoa(Array\n    .from(encodedPayload)\n    .map((item, key) => (String.fromCharCode(item.charCodeAt(0) ^ JWT_SECRET[key\n    % JWT_SECRET.length].charCodeAt(0))))\n    .join(''));\n\n  if (verifiedSignature !== signature) {\n    throw new Error('Invalid signature');\n  }\n\n  return payload;\n};\n\nexport const verify = (token, privateKey) => {\n  const [encodedHeader, encodedPayload, signature] = token.split('.');\n  const header = JSON.parse(atob(encodedHeader));\n  const payload = JSON.parse(atob(encodedPayload));\n  const now = new Date();\n\n  if (now < header.expiresIn) {\n    throw new Error('Expired token');\n  }\n\n  const verifiedSignature = btoa(Array\n    .from(encodedPayload)\n    .map((item, key) => (String.fromCharCode(item.charCodeAt(0) ^ privateKey[key\n    % privateKey.length].charCodeAt(0))))\n    .join(''));\n\n  if (verifiedSignature !== signature) {\n    throw new Error('Invalid signature');\n  }\n\n  return payload;\n};\n"]},"metadata":{},"sourceType":"module"}