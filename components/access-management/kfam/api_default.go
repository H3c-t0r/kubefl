/*
 * Kubeflow Auth
 *
 * Access Management API.
 *
 * API version: 1.0.0
 * Contact: kubeflow-engineering@google.com
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package kfam

import (
	"encoding/json"
	"github.com/kubeflow/kubeflow/components/access-management/pkg/apis/kubeflow/v1alpha1"
	rbacv1 "k8s.io/api/rbac/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/runtime/serializer"
	"k8s.io/client-go/kubernetes/scheme"
	"k8s.io/client-go/rest"
	_ "k8s.io/client-go/plugin/pkg/client/auth/gcp"
	"net/http"
	"os"
	"path"
	"sigs.k8s.io/controller-runtime/pkg/client/config"
)

type KfamV1Alpha1Interface interface {
	//Profiles(namespace string) ProfileInterface
	CreateProfile(w http.ResponseWriter, r *http.Request)
	DeleteProfile(w http.ResponseWriter, r *http.Request)
}

type KfamV1Alpha1Client struct {
	profileClient ProfileInterface
}

func NewProfileConfig() (*KfamV1Alpha1Client, error) {
	config, err := config.GetConfig()
	if err != nil {
		os.Exit(1)
	}
	config.ContentConfig.GroupVersion = &schema.GroupVersion{Group: v1alpha1.GroupName, Version: v1alpha1.GroupVersion}
	config.APIPath = "/apis"
	config.NegotiatedSerializer = serializer.DirectCodecFactory{CodecFactory: scheme.Codecs}
	config.UserAgent = rest.DefaultKubernetesUserAgent()

	client, err := rest.RESTClientFor(config)
	if err != nil {
		return nil, err
	}

	return &KfamV1Alpha1Client{
		profileClient: &profileClient{
			restClient: client,
			resource:   "profiles",
		},
	}, nil
}

func CreateBinding(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func (c *KfamV1Alpha1Client) CreateProfile(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	var profile Profile
	if err := json.NewDecoder(r.Body).Decode(&profile); err != nil {
		json.NewEncoder(w).Encode(err)
		w.WriteHeader(http.StatusForbidden)
		return
	}
	_, err := c.profileClient.Create(&v1alpha1.Profile{
		ObjectMeta: metav1.ObjectMeta{
			Name:      profile.Metadata.Name,
			Namespace: profile.Metadata.Name,
		},
		Spec: v1alpha1.ProfileSpec{
			Owner: rbacv1.Subject{
				Kind: 		profile.Spec.Owner.Kind,
				Name: 		profile.Spec.Owner.Name,
				Namespace: 	profile.Spec.Owner.Namespace,
			},
		},
	})
	if err == nil {
		w.WriteHeader(http.StatusOK)
	} else {
		w.WriteHeader(http.StatusForbidden)
		w.Write([]byte(err.Error()))
	}
}

func DeleteBinding(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func (c *KfamV1Alpha1Client) DeleteProfile(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	profileName := path.Base(r.RequestURI)
	//TODO: check permission before delete
	err := c.profileClient.Delete(profileName, nil)
	if err == nil {
		w.WriteHeader(http.StatusOK)
	} else {
		w.WriteHeader(http.StatusUnauthorized)
		w.Write([]byte(err.Error()))
	}
}

func ReadBinding(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}
