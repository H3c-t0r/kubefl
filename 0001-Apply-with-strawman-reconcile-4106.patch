From 9a25c2bc72190fa2a5e68398cedf4b4a95ccb4db Mon Sep 17 00:00:00 2001
From: Hung-Ting Wen <gabrielwen@google.com>
Date: Sat, 14 Sep 2019 18:14:38 -0700
Subject: [PATCH] Apply with strawman reconcile (#4106)

* Apply with strawman reconcile

* update simpleReconcile

* add simple requeue

* revert reconcile in platform
---
 .../pkg/kfapp/coordinator/coordinator.go      | 64 +++++++++++++++----
 1 file changed, 51 insertions(+), 13 deletions(-)

diff --git a/bootstrap/pkg/kfapp/coordinator/coordinator.go b/bootstrap/pkg/kfapp/coordinator/coordinator.go
index 5c9be171..eabb3189 100644
--- a/bootstrap/pkg/kfapp/coordinator/coordinator.go
+++ b/bootstrap/pkg/kfapp/coordinator/coordinator.go
@@ -24,6 +24,7 @@ import (
 
 	"os"
 
+	"github.com/cenkalti/backoff"
 	"github.com/ghodss/yaml"
 	"github.com/kubeflow/kfctl/bootstrap/v3/config"
 	kfapis "github.com/kubeflow/kfctl/bootstrap/v3/pkg/apis"
@@ -38,6 +39,7 @@ import (
 	log "github.com/sirupsen/logrus"
 	valid "k8s.io/apimachinery/pkg/api/validation"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"time"
 )
 
 // Builder defines the methods used to create KfApps.
@@ -208,6 +210,45 @@ func repoVersionToUri(repo string, version string) string {
 	return tarballUrl
 }
 
+// A strawman approach for reconcile semantics. We keep retrying until the fn returns nil.
+type simpleReconcileReq struct {
+	Fn      func() error
+	Requeue bool
+}
+
+func newReconcileReq(fn func() error) simpleReconcileReq {
+	return simpleReconcileReq{
+		Fn:      fn,
+		Requeue: true,
+	}
+}
+
+func simpleReconcile(requests []simpleReconcileReq) error {
+	return backoff.Retry(func() error {
+		retry := false
+		for idx := range requests {
+			if requests[idx].Requeue == false {
+				continue
+			}
+
+			if err := requests[idx].Fn(); err == nil {
+				requests[idx].Requeue = false
+			} else {
+				log.Warnf("reconcile process has error: %v; retrying...", err)
+				requests[idx].Requeue = true
+				retry = true
+			}
+		}
+
+		if retry {
+			return fmt.Errorf("Retrying to reconcile in 10 seconds.")
+		} else {
+			// Exit the simple reconcile.
+			return nil
+		}
+	}, backoff.NewConstantBackOff(10*time.Second))
+}
+
 // CreateKfDefFromOptions creates a KfDef from the supplied options.
 func CreateKfDefFromOptions(options map[string]interface{}) (*kfdefsv3.KfDef, error) {
 	//appName can be a path
@@ -774,24 +815,21 @@ func (kfapp *coordinator) Apply(resources kftypesv3.ResourceEnum) error {
 		}
 	}
 
+	// TODO(gabrielwen): Move `gcpAddedConfig` back to gcp.go.
 	switch resources {
 	case kftypesv3.ALL:
-		if err := platform(); err != nil {
-			return err
-		}
-		if err := k8s(); err != nil {
-			return err
-		}
-		return gcpAddedConfig()
+		return simpleReconcile([]simpleReconcileReq{
+			newReconcileReq(platform),
+			newReconcileReq(k8s),
+			newReconcileReq(gcpAddedConfig),
+		})
 	case kftypesv3.PLATFORM:
 		return platform()
 	case kftypesv3.K8S:
-		if err := k8s(); err != nil {
-			return err
-		}
-		// TODO(gabrielwen): Need to find a more proper way of injecting plugings.
-		// https://github.com/kubeflow/kfctl/issues/3708
-		return gcpAddedConfig()
+		return simpleReconcile([]simpleReconcileReq{
+			newReconcileReq(k8s),
+			newReconcileReq(gcpAddedConfig),
+		})
 	}
 	return nil
 }
-- 
2.23.0.237.gc6a4ce50a0-goog

