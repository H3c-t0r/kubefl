/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package v1alpha1

import (
	"bytes"
	"fmt"
	"github.com/cenkalti/backoff"
	"github.com/ksonnet/ksonnet/pkg/actions"
	"github.com/ksonnet/ksonnet/pkg/client"
	"github.com/kubeflow/kubeflow/bootstrap/pkg/apis/apps/v1alpha1"
	"github.com/ksonnet/ksonnet/pkg/app"
	"github.com/spf13/afero"
	log "github.com/sirupsen/logrus"
	"github.com/stretchr/testify/require"
	"k8s.io/client-go/tools/clientcmd"
	"k8s.io/kubernetes/pkg/kubectl/cmd/config"
	clientcmdapi "k8s.io/client-go/tools/clientcmd/api"
	"time"
)

type KfApi interface {
	Libraries() (map[string]*v1alpha1.KsLibrary, error)
	Registries() (map[string]*v1alpha1.KsRegistry, error)
	Components() (map[string]*v1alpha1.KsComponent, error)
	Root() string
	Apply(components []string) error
	Init(m map[string]interface{}) error
	EnvSet(m map[string]interface{}) error
	ParamSet(m map[string]interface{}) error
	PkgInstall(map[string]interface{}) error
	PrototypeUse(m map[string]interface{}) error
	RegistryAdd(m map[string]interface{}) error
}

// ksServer provides a server to wrap ksonnet.
// This allows ksonnet applications to be managed remotely.
type kfApi struct {
	appName string
	// appsDir is the directory where apps should be stored.
	appsDir string
	// knownRegistries is a list of known registries
	// This can be used to map the name of a registry to info about the registry.
	// This allows apps to specify a registry by name without having to know any
	// other information about the regisry.
	knownRegistries map[string]v1alpha1.RegistryConfig

	fs afero.Fs
	kApp app.App
}

func NewKfApi(appName string, appsDir string) (KfApi) {
	return &kfApi{
		appName: appName,
		appsDir: appsDir,
	}
}

func (kfApi *kfApi) Libraries() (map[string]*v1alpha1.KsLibrary, error) {
	kApp, err := app.Load(kfApi.fs, nil, kfApi.appsDir)
	if err != nil {
		return nil, fmt.Errorf("There was a problem loading app %v. Error: %v", kfApi.appName, err)
	}
	kfApi.kApp = kApp

	libs, error :=  kfApi.kApp.Libraries()
	if error != nil {
		return nil, fmt.Errorf("There was a problem getting the libraries %v. Error: %v", kfApi.appName, error)
	}

	libraries := make(map[string]*v1alpha1.KsLibrary)
	for k, v := range libs {
		libraries[k] = &v1alpha1.KsLibrary{
			Name: v.Name,
			Registry: v.Registry,
			Version: v.Version,
		}
	}
	return libraries, nil
}

func (kfApi *kfApi) Registries() (map[string]*v1alpha1.KsRegistry, error) {
	regs, err := kfApi.kApp.Registries()
	if err != nil {
		return nil, fmt.Errorf("There was a problem getting the Registries %v. Error: %v", kfApi.appName, err)
	}

	registries := make(map[string]*v1alpha1.KsRegistry)
	for k, v := range regs {
		registries[k] = &v1alpha1.KsRegistry{
			Name:     v.Name,
			Protocol: v.Protocol,
			URI:      v.URI,
		}
	}

	return registries, nil
}

func (kfApi *kfApi) Components() (map[string]*v1alpha1.KsComponent, error) {
	moduleName := "/"

	in := map[string]interface{}{
		actions.OptionApp: kfApi.kApp,
		actions.OptionModule: moduleName,
		actions.OptionOutput: tc.output,
	}

	a, err := actions.NewComponentList(in)
	if err != nil {
		return nil, fmt.Errorf("There was a problem getting the Components %v. Error: %v", kfApi.appName, err)
	}
	var buf bytes.Buffer
	a.out = &buf

	err = a.Run()

}

func (kfApi *kfApi) Root() string {
	return kfApi.kApp.Root()
}

func (kfApi *kfApi) Apply(components []string) error {
	cfg := clientcmdapi.Config{
		Kind:       "Config",
		APIVersion: "v1",
		Clusters: map[string]*clientcmdapi.Cluster{
			"activeCluster": {
				CertificateAuthorityData: config.TLSClientConfig.CAData,
				Server:                   config.Host,
			},
		},
		Contexts: map[string]*clientcmdapi.Context{
			"activeCluster": {
				Cluster:  "activeCluster",
				AuthInfo: "activeCluster",
			},
		},
		CurrentContext: "activeCluster",
		AuthInfos: map[string]*clientcmdapi.AuthInfo{
			"activeCluster": {
				Token: token,
			},
		},
	}

	applyOptions := map[string]interface{}{
		actions.OptionApp: kfApi.kApp,
		actions.OptionClientConfig: &client.Config{
			Overrides: &clientcmd.ConfigOverrides{},
			Config:    clientcmd.NewDefaultClientConfig(cfg, &clientcmd.ConfigOverrides{}),
		},
		actions.OptionComponentNames: components,
		actions.OptionCreate:         true,
		actions.OptionDryRun:         false,
		actions.OptionEnvName:        "default",
		actions.OptionGcTag:          "gc-tag",
		actions.OptionSkipGc:         true,
	}
	bo := backoff.WithMaxRetries(backoff.NewConstantBackOff(5*time.Second), 6)
	doneApply := make(map[string]bool)
	err := backoff.Retry(func() error {
		for _, comp := range components {
			if _, ok := doneApply[comp]; ok {
				continue
			}
			applyOptions[actions.OptionComponentNames] = []string{comp}
			err := actions.RunApply(applyOptions)
			if err == nil {
				log.Infof("Component %v apply succeeded", comp)
				doneApply[comp] = true
			} else {
				log.Errorf("(Will retry) Component %v apply failed; Error: %v", comp, err)
			}
		}
		if len(doneApply) == len(components) {
			return nil
		}
		return fmt.Errorf("%v failed components in last try", len(components)-len(doneApply))
	}, bo)
	if err != nil {
		log.Errorf("Components apply failed; Error: %v", err)
	} else {
		log.Infof("All components apply succeeded")
	}
	return err

}

func (kfApi *kfApi) Init(m map[string]interface{}) error {
	return nil
}

func (kfApi *kfApi) EnvSet(m map[string]interface{}) error {
	return nil
}

func (kfApi *kfApi) ParamSet(m map[string]interface{}) error {
	return nil
}

func (kfApi *kfApi) PkgInstall(m map[string]interface{}) error {
	return nil
}

func (kfApi *kfApi) PrototypeUse(m map[string]interface{}) error {
	return nil
}

func (kfApi *kfApi) RegistryAdd(m map[string]interface{}) error {
	return nil
}







